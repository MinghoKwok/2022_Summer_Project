// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mapRes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mapRes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mapRes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mapRes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mapRes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mapRes_2eproto;
namespace kernel {
class mapRes;
struct mapResDefaultTypeInternal;
extern mapResDefaultTypeInternal _mapRes_default_instance_;
class mapRes_FuncInfo;
struct mapRes_FuncInfoDefaultTypeInternal;
extern mapRes_FuncInfoDefaultTypeInternal _mapRes_FuncInfo_default_instance_;
class mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse;
struct mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUseDefaultTypeInternal;
extern mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUseDefaultTypeInternal _mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse_default_instance_;
class mapRes_FuncInfo_SASSLineInfo;
struct mapRes_FuncInfo_SASSLineInfoDefaultTypeInternal;
extern mapRes_FuncInfo_SASSLineInfoDefaultTypeInternal _mapRes_FuncInfo_SASSLineInfo_default_instance_;
class mapRes_FuncInfo_SASSLineInfo_Register;
struct mapRes_FuncInfo_SASSLineInfo_RegisterDefaultTypeInternal;
extern mapRes_FuncInfo_SASSLineInfo_RegisterDefaultTypeInternal _mapRes_FuncInfo_SASSLineInfo_Register_default_instance_;
class mapRes_TestMapEntry_DoNotUse;
struct mapRes_TestMapEntry_DoNotUseDefaultTypeInternal;
extern mapRes_TestMapEntry_DoNotUseDefaultTypeInternal _mapRes_TestMapEntry_DoNotUse_default_instance_;
}  // namespace kernel
PROTOBUF_NAMESPACE_OPEN
template<> ::kernel::mapRes* Arena::CreateMaybeMessage<::kernel::mapRes>(Arena*);
template<> ::kernel::mapRes_FuncInfo* Arena::CreateMaybeMessage<::kernel::mapRes_FuncInfo>(Arena*);
template<> ::kernel::mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse* Arena::CreateMaybeMessage<::kernel::mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse>(Arena*);
template<> ::kernel::mapRes_FuncInfo_SASSLineInfo* Arena::CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo>(Arena*);
template<> ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* Arena::CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>(Arena*);
template<> ::kernel::mapRes_TestMapEntry_DoNotUse* Arena::CreateMaybeMessage<::kernel::mapRes_TestMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kernel {

// ===================================================================

class mapRes_TestMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<mapRes_TestMapEntry_DoNotUse, 
    std::string, ::kernel::mapRes_FuncInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<mapRes_TestMapEntry_DoNotUse, 
    std::string, ::kernel::mapRes_FuncInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  mapRes_TestMapEntry_DoNotUse();
  explicit constexpr mapRes_TestMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit mapRes_TestMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const mapRes_TestMapEntry_DoNotUse& other);
  static const mapRes_TestMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const mapRes_TestMapEntry_DoNotUse*>(&_mapRes_TestMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "kernel.mapRes.TestMapEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse();
  explicit constexpr mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse& other);
  static const mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse*>(&_mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class mapRes_FuncInfo_SASSLineInfo_Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kernel.mapRes.FuncInfo.SASSLineInfo.Register) */ {
 public:
  inline mapRes_FuncInfo_SASSLineInfo_Register() : mapRes_FuncInfo_SASSLineInfo_Register(nullptr) {}
  ~mapRes_FuncInfo_SASSLineInfo_Register() override;
  explicit constexpr mapRes_FuncInfo_SASSLineInfo_Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mapRes_FuncInfo_SASSLineInfo_Register(const mapRes_FuncInfo_SASSLineInfo_Register& from);
  mapRes_FuncInfo_SASSLineInfo_Register(mapRes_FuncInfo_SASSLineInfo_Register&& from) noexcept
    : mapRes_FuncInfo_SASSLineInfo_Register() {
    *this = ::std::move(from);
  }

  inline mapRes_FuncInfo_SASSLineInfo_Register& operator=(const mapRes_FuncInfo_SASSLineInfo_Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline mapRes_FuncInfo_SASSLineInfo_Register& operator=(mapRes_FuncInfo_SASSLineInfo_Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mapRes_FuncInfo_SASSLineInfo_Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const mapRes_FuncInfo_SASSLineInfo_Register* internal_default_instance() {
    return reinterpret_cast<const mapRes_FuncInfo_SASSLineInfo_Register*>(
               &_mapRes_FuncInfo_SASSLineInfo_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(mapRes_FuncInfo_SASSLineInfo_Register& a, mapRes_FuncInfo_SASSLineInfo_Register& b) {
    a.Swap(&b);
  }
  inline void Swap(mapRes_FuncInfo_SASSLineInfo_Register* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mapRes_FuncInfo_SASSLineInfo_Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mapRes_FuncInfo_SASSLineInfo_Register* New() const final {
    return new mapRes_FuncInfo_SASSLineInfo_Register();
  }

  mapRes_FuncInfo_SASSLineInfo_Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mapRes_FuncInfo_SASSLineInfo_Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mapRes_FuncInfo_SASSLineInfo_Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const mapRes_FuncInfo_SASSLineInfo_Register& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mapRes_FuncInfo_SASSLineInfo_Register* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kernel.mapRes.FuncInfo.SASSLineInfo.Register";
  }
  protected:
  explicit mapRes_FuncInfo_SASSLineInfo_Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegStatusFieldNumber = 4,
    kNameFieldNumber = 1,
    kSizeFieldNumber = 2,
    kOccupiedCountFieldNumber = 3,
  };
  // repeated uint64 reg_status = 4;
  int reg_status_size() const;
  private:
  int _internal_reg_status_size() const;
  public:
  void clear_reg_status();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reg_status(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_reg_status() const;
  void _internal_add_reg_status(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_reg_status();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_status(int index) const;
  void set_reg_status(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_reg_status(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      reg_status() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_reg_status();

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 occupied_count = 3;
  bool has_occupied_count() const;
  private:
  bool _internal_has_occupied_count() const;
  public:
  void clear_occupied_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 occupied_count() const;
  void set_occupied_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_occupied_count() const;
  void _internal_set_occupied_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:kernel.mapRes.FuncInfo.SASSLineInfo.Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > reg_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 occupied_count_;
  friend struct ::TableStruct_mapRes_2eproto;
};
// -------------------------------------------------------------------

class mapRes_FuncInfo_SASSLineInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kernel.mapRes.FuncInfo.SASSLineInfo) */ {
 public:
  inline mapRes_FuncInfo_SASSLineInfo() : mapRes_FuncInfo_SASSLineInfo(nullptr) {}
  ~mapRes_FuncInfo_SASSLineInfo() override;
  explicit constexpr mapRes_FuncInfo_SASSLineInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mapRes_FuncInfo_SASSLineInfo(const mapRes_FuncInfo_SASSLineInfo& from);
  mapRes_FuncInfo_SASSLineInfo(mapRes_FuncInfo_SASSLineInfo&& from) noexcept
    : mapRes_FuncInfo_SASSLineInfo() {
    *this = ::std::move(from);
  }

  inline mapRes_FuncInfo_SASSLineInfo& operator=(const mapRes_FuncInfo_SASSLineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline mapRes_FuncInfo_SASSLineInfo& operator=(mapRes_FuncInfo_SASSLineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mapRes_FuncInfo_SASSLineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const mapRes_FuncInfo_SASSLineInfo* internal_default_instance() {
    return reinterpret_cast<const mapRes_FuncInfo_SASSLineInfo*>(
               &_mapRes_FuncInfo_SASSLineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(mapRes_FuncInfo_SASSLineInfo& a, mapRes_FuncInfo_SASSLineInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(mapRes_FuncInfo_SASSLineInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mapRes_FuncInfo_SASSLineInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mapRes_FuncInfo_SASSLineInfo* New() const final {
    return new mapRes_FuncInfo_SASSLineInfo();
  }

  mapRes_FuncInfo_SASSLineInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mapRes_FuncInfo_SASSLineInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mapRes_FuncInfo_SASSLineInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const mapRes_FuncInfo_SASSLineInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mapRes_FuncInfo_SASSLineInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kernel.mapRes.FuncInfo.SASSLineInfo";
  }
  protected:
  explicit mapRes_FuncInfo_SASSLineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef mapRes_FuncInfo_SASSLineInfo_Register Register;

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPathFieldNumber = 1,
    kCodeFieldNumber = 3,
    kRegGPRFieldNumber = 4,
    kRegPREDFieldNumber = 5,
    kRegUGPRFieldNumber = 6,
    kRegUPREDFieldNumber = 7,
    kSrcLineFieldNumber = 2,
  };
  // required string src_path = 1;
  bool has_src_path() const;
  private:
  bool _internal_has_src_path() const;
  public:
  void clear_src_path();
  const std::string& src_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_src_path();
  void set_allocated_src_path(std::string* src_path);
  private:
  const std::string& _internal_src_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_path(const std::string& value);
  std::string* _internal_mutable_src_path();
  public:

  // required string code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_GPR = 4;
  bool has_reg_gpr() const;
  private:
  bool _internal_has_reg_gpr() const;
  public:
  void clear_reg_gpr();
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& reg_gpr() const;
  PROTOBUF_MUST_USE_RESULT ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* release_reg_gpr();
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mutable_reg_gpr();
  void set_allocated_reg_gpr(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_gpr);
  private:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& _internal_reg_gpr() const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _internal_mutable_reg_gpr();
  public:
  void unsafe_arena_set_allocated_reg_gpr(
      ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_gpr);
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* unsafe_arena_release_reg_gpr();

  // optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_PRED = 5;
  bool has_reg_pred() const;
  private:
  bool _internal_has_reg_pred() const;
  public:
  void clear_reg_pred();
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& reg_pred() const;
  PROTOBUF_MUST_USE_RESULT ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* release_reg_pred();
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mutable_reg_pred();
  void set_allocated_reg_pred(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_pred);
  private:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& _internal_reg_pred() const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _internal_mutable_reg_pred();
  public:
  void unsafe_arena_set_allocated_reg_pred(
      ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_pred);
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* unsafe_arena_release_reg_pred();

  // optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_UGPR = 6;
  bool has_reg_ugpr() const;
  private:
  bool _internal_has_reg_ugpr() const;
  public:
  void clear_reg_ugpr();
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& reg_ugpr() const;
  PROTOBUF_MUST_USE_RESULT ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* release_reg_ugpr();
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mutable_reg_ugpr();
  void set_allocated_reg_ugpr(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_ugpr);
  private:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& _internal_reg_ugpr() const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _internal_mutable_reg_ugpr();
  public:
  void unsafe_arena_set_allocated_reg_ugpr(
      ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_ugpr);
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* unsafe_arena_release_reg_ugpr();

  // optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_UPRED = 7;
  bool has_reg_upred() const;
  private:
  bool _internal_has_reg_upred() const;
  public:
  void clear_reg_upred();
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& reg_upred() const;
  PROTOBUF_MUST_USE_RESULT ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* release_reg_upred();
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mutable_reg_upred();
  void set_allocated_reg_upred(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_upred);
  private:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& _internal_reg_upred() const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _internal_mutable_reg_upred();
  public:
  void unsafe_arena_set_allocated_reg_upred(
      ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_upred);
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* unsafe_arena_release_reg_upred();

  // required uint64 src_line = 2;
  bool has_src_line() const;
  private:
  bool _internal_has_src_line() const;
  public:
  void clear_src_line();
  ::PROTOBUF_NAMESPACE_ID::uint64 src_line() const;
  void set_src_line(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_src_line() const;
  void _internal_set_src_line(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:kernel.mapRes.FuncInfo.SASSLineInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_gpr_;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_pred_;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_ugpr_;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_upred_;
  ::PROTOBUF_NAMESPACE_ID::uint64 src_line_;
  friend struct ::TableStruct_mapRes_2eproto;
};
// -------------------------------------------------------------------

class mapRes_FuncInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kernel.mapRes.FuncInfo) */ {
 public:
  inline mapRes_FuncInfo() : mapRes_FuncInfo(nullptr) {}
  ~mapRes_FuncInfo() override;
  explicit constexpr mapRes_FuncInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mapRes_FuncInfo(const mapRes_FuncInfo& from);
  mapRes_FuncInfo(mapRes_FuncInfo&& from) noexcept
    : mapRes_FuncInfo() {
    *this = ::std::move(from);
  }

  inline mapRes_FuncInfo& operator=(const mapRes_FuncInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline mapRes_FuncInfo& operator=(mapRes_FuncInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mapRes_FuncInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const mapRes_FuncInfo* internal_default_instance() {
    return reinterpret_cast<const mapRes_FuncInfo*>(
               &_mapRes_FuncInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(mapRes_FuncInfo& a, mapRes_FuncInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(mapRes_FuncInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mapRes_FuncInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mapRes_FuncInfo* New() const final {
    return new mapRes_FuncInfo();
  }

  mapRes_FuncInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mapRes_FuncInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mapRes_FuncInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const mapRes_FuncInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mapRes_FuncInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kernel.mapRes.FuncInfo";
  }
  protected:
  explicit mapRes_FuncInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef mapRes_FuncInfo_SASSLineInfo SASSLineInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFileSetFieldNumber = 2,
    kCodeSetFieldNumber = 3,
    kMapOffsetSrcFieldNumber = 4,
    kSASSLineFieldNumber = 5,
    kFuncnameFieldNumber = 1,
    kRegGPRSizeFieldNumber = 6,
    kRegPREDSizeFieldNumber = 7,
    kRegUGPRSizeFieldNumber = 8,
    kRegUPREDSizeFieldNumber = 9,
  };
  // repeated string srcFileSet = 2;
  int srcfileset_size() const;
  private:
  int _internal_srcfileset_size() const;
  public:
  void clear_srcfileset();
  const std::string& srcfileset(int index) const;
  std::string* mutable_srcfileset(int index);
  void set_srcfileset(int index, const std::string& value);
  void set_srcfileset(int index, std::string&& value);
  void set_srcfileset(int index, const char* value);
  void set_srcfileset(int index, const char* value, size_t size);
  std::string* add_srcfileset();
  void add_srcfileset(const std::string& value);
  void add_srcfileset(std::string&& value);
  void add_srcfileset(const char* value);
  void add_srcfileset(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& srcfileset() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_srcfileset();
  private:
  const std::string& _internal_srcfileset(int index) const;
  std::string* _internal_add_srcfileset();
  public:

  // repeated string codeSet = 3;
  int codeset_size() const;
  private:
  int _internal_codeset_size() const;
  public:
  void clear_codeset();
  const std::string& codeset(int index) const;
  std::string* mutable_codeset(int index);
  void set_codeset(int index, const std::string& value);
  void set_codeset(int index, std::string&& value);
  void set_codeset(int index, const char* value);
  void set_codeset(int index, const char* value, size_t size);
  std::string* add_codeset();
  void add_codeset(const std::string& value);
  void add_codeset(std::string&& value);
  void add_codeset(const char* value);
  void add_codeset(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& codeset() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_codeset();
  private:
  const std::string& _internal_codeset(int index) const;
  std::string* _internal_add_codeset();
  public:

  // map<uint64, .kernel.mapRes.FuncInfo.SASSLineInfo> map_offset_src = 4;
  int map_offset_src_size() const;
  private:
  int _internal_map_offset_src_size() const;
  public:
  void clear_map_offset_src();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >&
      _internal_map_offset_src() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >*
      _internal_mutable_map_offset_src();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >&
      map_offset_src() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >*
      mutable_map_offset_src();

  // repeated .kernel.mapRes.FuncInfo.SASSLineInfo SASSLine = 5;
  int sassline_size() const;
  private:
  int _internal_sassline_size() const;
  public:
  void clear_sassline();
  ::kernel::mapRes_FuncInfo_SASSLineInfo* mutable_sassline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo_SASSLineInfo >*
      mutable_sassline();
  private:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo& _internal_sassline(int index) const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo* _internal_add_sassline();
  public:
  const ::kernel::mapRes_FuncInfo_SASSLineInfo& sassline(int index) const;
  ::kernel::mapRes_FuncInfo_SASSLineInfo* add_sassline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo_SASSLineInfo >&
      sassline() const;

  // required string funcname = 1;
  bool has_funcname() const;
  private:
  bool _internal_has_funcname() const;
  public:
  void clear_funcname();
  const std::string& funcname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_funcname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_funcname();
  PROTOBUF_MUST_USE_RESULT std::string* release_funcname();
  void set_allocated_funcname(std::string* funcname);
  private:
  const std::string& _internal_funcname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_funcname(const std::string& value);
  std::string* _internal_mutable_funcname();
  public:

  // optional uint64 reg_GPR_size = 6;
  bool has_reg_gpr_size() const;
  private:
  bool _internal_has_reg_gpr_size() const;
  public:
  void clear_reg_gpr_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_gpr_size() const;
  void set_reg_gpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reg_gpr_size() const;
  void _internal_set_reg_gpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 reg_PRED_size = 7;
  bool has_reg_pred_size() const;
  private:
  bool _internal_has_reg_pred_size() const;
  public:
  void clear_reg_pred_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_pred_size() const;
  void set_reg_pred_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reg_pred_size() const;
  void _internal_set_reg_pred_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 reg_UGPR_size = 8;
  bool has_reg_ugpr_size() const;
  private:
  bool _internal_has_reg_ugpr_size() const;
  public:
  void clear_reg_ugpr_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_ugpr_size() const;
  void set_reg_ugpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reg_ugpr_size() const;
  void _internal_set_reg_ugpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 reg_UPRED_size = 9;
  bool has_reg_upred_size() const;
  private:
  bool _internal_has_reg_upred_size() const;
  public:
  void clear_reg_upred_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_upred_size() const;
  void set_reg_upred_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_reg_upred_size() const;
  void _internal_set_reg_upred_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:kernel.mapRes.FuncInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> srcfileset_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> codeset_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      mapRes_FuncInfo_MapOffsetSrcEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> map_offset_src_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo_SASSLineInfo > sassline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr funcname_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_gpr_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_pred_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_ugpr_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 reg_upred_size_;
  friend struct ::TableStruct_mapRes_2eproto;
};
// -------------------------------------------------------------------

class mapRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kernel.mapRes) */ {
 public:
  inline mapRes() : mapRes(nullptr) {}
  ~mapRes() override;
  explicit constexpr mapRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mapRes(const mapRes& from);
  mapRes(mapRes&& from) noexcept
    : mapRes() {
    *this = ::std::move(from);
  }

  inline mapRes& operator=(const mapRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline mapRes& operator=(mapRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mapRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const mapRes* internal_default_instance() {
    return reinterpret_cast<const mapRes*>(
               &_mapRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(mapRes& a, mapRes& b) {
    a.Swap(&b);
  }
  inline void Swap(mapRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mapRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mapRes* New() const final {
    return new mapRes();
  }

  mapRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mapRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mapRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const mapRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mapRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kernel.mapRes";
  }
  protected:
  explicit mapRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef mapRes_FuncInfo FuncInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kTestMapFieldNumber = 1,
    kFIFieldNumber = 2,
  };
  // map<string, .kernel.mapRes.FuncInfo> testMap = 1;
  int testmap_size() const;
  private:
  int _internal_testmap_size() const;
  public:
  void clear_testmap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >&
      _internal_testmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >*
      _internal_mutable_testmap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >&
      testmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >*
      mutable_testmap();

  // repeated .kernel.mapRes.FuncInfo FI = 2;
  int fi_size() const;
  private:
  int _internal_fi_size() const;
  public:
  void clear_fi();
  ::kernel::mapRes_FuncInfo* mutable_fi(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo >*
      mutable_fi();
  private:
  const ::kernel::mapRes_FuncInfo& _internal_fi(int index) const;
  ::kernel::mapRes_FuncInfo* _internal_add_fi();
  public:
  const ::kernel::mapRes_FuncInfo& fi(int index) const;
  ::kernel::mapRes_FuncInfo* add_fi();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo >&
      fi() const;

  // @@protoc_insertion_point(class_scope:kernel.mapRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      mapRes_TestMapEntry_DoNotUse,
      std::string, ::kernel::mapRes_FuncInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> testmap_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo > fi_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mapRes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// mapRes_FuncInfo_SASSLineInfo_Register

// optional string name = 1;
inline bool mapRes_FuncInfo_SASSLineInfo_Register::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo_Register::has_name() const {
  return _internal_has_name();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo_Register::name() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.Register.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mapRes_FuncInfo_SASSLineInfo_Register::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.Register.name)
}
inline std::string* mapRes_FuncInfo_SASSLineInfo_Register::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.Register.name)
  return _s;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo_Register::_internal_name() const {
  return name_.Get();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo_Register::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo_Register::release_name() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.Register.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.Register.name)
}

// optional uint64 size = 2;
inline bool mapRes_FuncInfo_SASSLineInfo_Register::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo_Register::has_size() const {
  return _internal_has_size();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::clear_size() {
  size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::size() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.Register.size)
  return _internal_size();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.Register.size)
}

// optional uint64 occupied_count = 3;
inline bool mapRes_FuncInfo_SASSLineInfo_Register::_internal_has_occupied_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo_Register::has_occupied_count() const {
  return _internal_has_occupied_count();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::clear_occupied_count() {
  occupied_count_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::_internal_occupied_count() const {
  return occupied_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::occupied_count() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.Register.occupied_count)
  return _internal_occupied_count();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::_internal_set_occupied_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  occupied_count_ = value;
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::set_occupied_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_occupied_count(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.Register.occupied_count)
}

// repeated uint64 reg_status = 4;
inline int mapRes_FuncInfo_SASSLineInfo_Register::_internal_reg_status_size() const {
  return reg_status_.size();
}
inline int mapRes_FuncInfo_SASSLineInfo_Register::reg_status_size() const {
  return _internal_reg_status_size();
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::clear_reg_status() {
  reg_status_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::_internal_reg_status(int index) const {
  return reg_status_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo_Register::reg_status(int index) const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.Register.reg_status)
  return _internal_reg_status(index);
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::set_reg_status(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  reg_status_.Set(index, value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.Register.reg_status)
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::_internal_add_reg_status(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  reg_status_.Add(value);
}
inline void mapRes_FuncInfo_SASSLineInfo_Register::add_reg_status(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_reg_status(value);
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.SASSLineInfo.Register.reg_status)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
mapRes_FuncInfo_SASSLineInfo_Register::_internal_reg_status() const {
  return reg_status_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
mapRes_FuncInfo_SASSLineInfo_Register::reg_status() const {
  // @@protoc_insertion_point(field_list:kernel.mapRes.FuncInfo.SASSLineInfo.Register.reg_status)
  return _internal_reg_status();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
mapRes_FuncInfo_SASSLineInfo_Register::_internal_mutable_reg_status() {
  return &reg_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
mapRes_FuncInfo_SASSLineInfo_Register::mutable_reg_status() {
  // @@protoc_insertion_point(field_mutable_list:kernel.mapRes.FuncInfo.SASSLineInfo.Register.reg_status)
  return _internal_mutable_reg_status();
}

// -------------------------------------------------------------------

// mapRes_FuncInfo_SASSLineInfo

// required string src_path = 1;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_src_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_src_path() const {
  return _internal_has_src_path();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_src_path() {
  src_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo::src_path() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.src_path)
  return _internal_src_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mapRes_FuncInfo_SASSLineInfo::set_src_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 src_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.src_path)
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::mutable_src_path() {
  std::string* _s = _internal_mutable_src_path();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.src_path)
  return _s;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo::_internal_src_path() const {
  return src_path_.Get();
}
inline void mapRes_FuncInfo_SASSLineInfo::_internal_set_src_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  src_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_src_path() {
  _has_bits_[0] |= 0x00000001u;
  return src_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::release_src_path() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.src_path)
  if (!_internal_has_src_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return src_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_src_path(std::string* src_path) {
  if (src_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.src_path)
}

// required uint64 src_line = 2;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_src_line() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_src_line() const {
  return _internal_has_src_line();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_src_line() {
  src_line_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo::_internal_src_line() const {
  return src_line_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo_SASSLineInfo::src_line() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.src_line)
  return _internal_src_line();
}
inline void mapRes_FuncInfo_SASSLineInfo::_internal_set_src_line(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  src_line_ = value;
}
inline void mapRes_FuncInfo_SASSLineInfo::set_src_line(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_src_line(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.src_line)
}

// required string code = 3;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_code() const {
  return _internal_has_code();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_code() {
  code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo::code() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mapRes_FuncInfo_SASSLineInfo::set_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.SASSLineInfo.code)
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.code)
  return _s;
}
inline const std::string& mapRes_FuncInfo_SASSLineInfo::_internal_code() const {
  return code_.Get();
}
inline void mapRes_FuncInfo_SASSLineInfo::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000002u;
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo_SASSLineInfo::release_code() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.code)
}

// optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_GPR = 4;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_reg_gpr() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || reg_gpr_ != nullptr);
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_reg_gpr() const {
  return _internal_has_reg_gpr();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_reg_gpr() {
  if (reg_gpr_ != nullptr) reg_gpr_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::_internal_reg_gpr() const {
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* p = reg_gpr_;
  return p != nullptr ? *p : reinterpret_cast<const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register&>(
      ::kernel::_mapRes_FuncInfo_SASSLineInfo_Register_default_instance_);
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::reg_gpr() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.reg_GPR)
  return _internal_reg_gpr();
}
inline void mapRes_FuncInfo_SASSLineInfo::unsafe_arena_set_allocated_reg_gpr(
    ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_gpr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_gpr_);
  }
  reg_gpr_ = reg_gpr;
  if (reg_gpr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_GPR)
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::release_reg_gpr() {
  _has_bits_[0] &= ~0x00000004u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_gpr_;
  reg_gpr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::unsafe_arena_release_reg_gpr() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.reg_GPR)
  _has_bits_[0] &= ~0x00000004u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_gpr_;
  reg_gpr_ = nullptr;
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_reg_gpr() {
  _has_bits_[0] |= 0x00000004u;
  if (reg_gpr_ == nullptr) {
    auto* p = CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>(GetArenaForAllocation());
    reg_gpr_ = p;
  }
  return reg_gpr_;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::mutable_reg_gpr() {
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _msg = _internal_mutable_reg_gpr();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.reg_GPR)
  return _msg;
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_reg_gpr(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_gpr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reg_gpr_;
  }
  if (reg_gpr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>::GetOwningArena(reg_gpr);
    if (message_arena != submessage_arena) {
      reg_gpr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reg_gpr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  reg_gpr_ = reg_gpr;
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_GPR)
}

// optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_PRED = 5;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_reg_pred() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || reg_pred_ != nullptr);
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_reg_pred() const {
  return _internal_has_reg_pred();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_reg_pred() {
  if (reg_pred_ != nullptr) reg_pred_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::_internal_reg_pred() const {
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* p = reg_pred_;
  return p != nullptr ? *p : reinterpret_cast<const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register&>(
      ::kernel::_mapRes_FuncInfo_SASSLineInfo_Register_default_instance_);
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::reg_pred() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.reg_PRED)
  return _internal_reg_pred();
}
inline void mapRes_FuncInfo_SASSLineInfo::unsafe_arena_set_allocated_reg_pred(
    ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_pred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_pred_);
  }
  reg_pred_ = reg_pred;
  if (reg_pred) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_PRED)
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::release_reg_pred() {
  _has_bits_[0] &= ~0x00000008u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_pred_;
  reg_pred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::unsafe_arena_release_reg_pred() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.reg_PRED)
  _has_bits_[0] &= ~0x00000008u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_pred_;
  reg_pred_ = nullptr;
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_reg_pred() {
  _has_bits_[0] |= 0x00000008u;
  if (reg_pred_ == nullptr) {
    auto* p = CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>(GetArenaForAllocation());
    reg_pred_ = p;
  }
  return reg_pred_;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::mutable_reg_pred() {
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _msg = _internal_mutable_reg_pred();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.reg_PRED)
  return _msg;
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_reg_pred(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_pred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reg_pred_;
  }
  if (reg_pred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>::GetOwningArena(reg_pred);
    if (message_arena != submessage_arena) {
      reg_pred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reg_pred, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  reg_pred_ = reg_pred;
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_PRED)
}

// optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_UGPR = 6;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_reg_ugpr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || reg_ugpr_ != nullptr);
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_reg_ugpr() const {
  return _internal_has_reg_ugpr();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_reg_ugpr() {
  if (reg_ugpr_ != nullptr) reg_ugpr_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::_internal_reg_ugpr() const {
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* p = reg_ugpr_;
  return p != nullptr ? *p : reinterpret_cast<const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register&>(
      ::kernel::_mapRes_FuncInfo_SASSLineInfo_Register_default_instance_);
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::reg_ugpr() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UGPR)
  return _internal_reg_ugpr();
}
inline void mapRes_FuncInfo_SASSLineInfo::unsafe_arena_set_allocated_reg_ugpr(
    ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_ugpr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_ugpr_);
  }
  reg_ugpr_ = reg_ugpr;
  if (reg_ugpr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UGPR)
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::release_reg_ugpr() {
  _has_bits_[0] &= ~0x00000010u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_ugpr_;
  reg_ugpr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::unsafe_arena_release_reg_ugpr() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UGPR)
  _has_bits_[0] &= ~0x00000010u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_ugpr_;
  reg_ugpr_ = nullptr;
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_reg_ugpr() {
  _has_bits_[0] |= 0x00000010u;
  if (reg_ugpr_ == nullptr) {
    auto* p = CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>(GetArenaForAllocation());
    reg_ugpr_ = p;
  }
  return reg_ugpr_;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::mutable_reg_ugpr() {
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _msg = _internal_mutable_reg_ugpr();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UGPR)
  return _msg;
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_reg_ugpr(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_ugpr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reg_ugpr_;
  }
  if (reg_ugpr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>::GetOwningArena(reg_ugpr);
    if (message_arena != submessage_arena) {
      reg_ugpr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reg_ugpr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  reg_ugpr_ = reg_ugpr;
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UGPR)
}

// optional .kernel.mapRes.FuncInfo.SASSLineInfo.Register reg_UPRED = 7;
inline bool mapRes_FuncInfo_SASSLineInfo::_internal_has_reg_upred() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || reg_upred_ != nullptr);
  return value;
}
inline bool mapRes_FuncInfo_SASSLineInfo::has_reg_upred() const {
  return _internal_has_reg_upred();
}
inline void mapRes_FuncInfo_SASSLineInfo::clear_reg_upred() {
  if (reg_upred_ != nullptr) reg_upred_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::_internal_reg_upred() const {
  const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* p = reg_upred_;
  return p != nullptr ? *p : reinterpret_cast<const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register&>(
      ::kernel::_mapRes_FuncInfo_SASSLineInfo_Register_default_instance_);
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo_Register& mapRes_FuncInfo_SASSLineInfo::reg_upred() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UPRED)
  return _internal_reg_upred();
}
inline void mapRes_FuncInfo_SASSLineInfo::unsafe_arena_set_allocated_reg_upred(
    ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_upred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reg_upred_);
  }
  reg_upred_ = reg_upred;
  if (reg_upred) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UPRED)
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::release_reg_upred() {
  _has_bits_[0] &= ~0x00000020u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_upred_;
  reg_upred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::unsafe_arena_release_reg_upred() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UPRED)
  _has_bits_[0] &= ~0x00000020u;
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* temp = reg_upred_;
  reg_upred_ = nullptr;
  return temp;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::_internal_mutable_reg_upred() {
  _has_bits_[0] |= 0x00000020u;
  if (reg_upred_ == nullptr) {
    auto* p = CreateMaybeMessage<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>(GetArenaForAllocation());
    reg_upred_ = p;
  }
  return reg_upred_;
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* mapRes_FuncInfo_SASSLineInfo::mutable_reg_upred() {
  ::kernel::mapRes_FuncInfo_SASSLineInfo_Register* _msg = _internal_mutable_reg_upred();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UPRED)
  return _msg;
}
inline void mapRes_FuncInfo_SASSLineInfo::set_allocated_reg_upred(::kernel::mapRes_FuncInfo_SASSLineInfo_Register* reg_upred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reg_upred_;
  }
  if (reg_upred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::kernel::mapRes_FuncInfo_SASSLineInfo_Register>::GetOwningArena(reg_upred);
    if (message_arena != submessage_arena) {
      reg_upred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reg_upred, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  reg_upred_ = reg_upred;
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.SASSLineInfo.reg_UPRED)
}

// -------------------------------------------------------------------

// mapRes_FuncInfo

// required string funcname = 1;
inline bool mapRes_FuncInfo::_internal_has_funcname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mapRes_FuncInfo::has_funcname() const {
  return _internal_has_funcname();
}
inline void mapRes_FuncInfo::clear_funcname() {
  funcname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mapRes_FuncInfo::funcname() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.funcname)
  return _internal_funcname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mapRes_FuncInfo::set_funcname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 funcname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.funcname)
}
inline std::string* mapRes_FuncInfo::mutable_funcname() {
  std::string* _s = _internal_mutable_funcname();
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.funcname)
  return _s;
}
inline const std::string& mapRes_FuncInfo::_internal_funcname() const {
  return funcname_.Get();
}
inline void mapRes_FuncInfo::_internal_set_funcname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  funcname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo::_internal_mutable_funcname() {
  _has_bits_[0] |= 0x00000001u;
  return funcname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* mapRes_FuncInfo::release_funcname() {
  // @@protoc_insertion_point(field_release:kernel.mapRes.FuncInfo.funcname)
  if (!_internal_has_funcname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return funcname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void mapRes_FuncInfo::set_allocated_funcname(std::string* funcname) {
  if (funcname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  funcname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), funcname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:kernel.mapRes.FuncInfo.funcname)
}

// repeated string srcFileSet = 2;
inline int mapRes_FuncInfo::_internal_srcfileset_size() const {
  return srcfileset_.size();
}
inline int mapRes_FuncInfo::srcfileset_size() const {
  return _internal_srcfileset_size();
}
inline void mapRes_FuncInfo::clear_srcfileset() {
  srcfileset_.Clear();
}
inline std::string* mapRes_FuncInfo::add_srcfileset() {
  std::string* _s = _internal_add_srcfileset();
  // @@protoc_insertion_point(field_add_mutable:kernel.mapRes.FuncInfo.srcFileSet)
  return _s;
}
inline const std::string& mapRes_FuncInfo::_internal_srcfileset(int index) const {
  return srcfileset_.Get(index);
}
inline const std::string& mapRes_FuncInfo::srcfileset(int index) const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.srcFileSet)
  return _internal_srcfileset(index);
}
inline std::string* mapRes_FuncInfo::mutable_srcfileset(int index) {
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.srcFileSet)
  return srcfileset_.Mutable(index);
}
inline void mapRes_FuncInfo::set_srcfileset(int index, const std::string& value) {
  srcfileset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::set_srcfileset(int index, std::string&& value) {
  srcfileset_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::set_srcfileset(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  srcfileset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::set_srcfileset(int index, const char* value, size_t size) {
  srcfileset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kernel.mapRes.FuncInfo.srcFileSet)
}
inline std::string* mapRes_FuncInfo::_internal_add_srcfileset() {
  return srcfileset_.Add();
}
inline void mapRes_FuncInfo::add_srcfileset(const std::string& value) {
  srcfileset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::add_srcfileset(std::string&& value) {
  srcfileset_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::add_srcfileset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  srcfileset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kernel.mapRes.FuncInfo.srcFileSet)
}
inline void mapRes_FuncInfo::add_srcfileset(const char* value, size_t size) {
  srcfileset_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kernel.mapRes.FuncInfo.srcFileSet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
mapRes_FuncInfo::srcfileset() const {
  // @@protoc_insertion_point(field_list:kernel.mapRes.FuncInfo.srcFileSet)
  return srcfileset_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
mapRes_FuncInfo::mutable_srcfileset() {
  // @@protoc_insertion_point(field_mutable_list:kernel.mapRes.FuncInfo.srcFileSet)
  return &srcfileset_;
}

// repeated string codeSet = 3;
inline int mapRes_FuncInfo::_internal_codeset_size() const {
  return codeset_.size();
}
inline int mapRes_FuncInfo::codeset_size() const {
  return _internal_codeset_size();
}
inline void mapRes_FuncInfo::clear_codeset() {
  codeset_.Clear();
}
inline std::string* mapRes_FuncInfo::add_codeset() {
  std::string* _s = _internal_add_codeset();
  // @@protoc_insertion_point(field_add_mutable:kernel.mapRes.FuncInfo.codeSet)
  return _s;
}
inline const std::string& mapRes_FuncInfo::_internal_codeset(int index) const {
  return codeset_.Get(index);
}
inline const std::string& mapRes_FuncInfo::codeset(int index) const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.codeSet)
  return _internal_codeset(index);
}
inline std::string* mapRes_FuncInfo::mutable_codeset(int index) {
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.codeSet)
  return codeset_.Mutable(index);
}
inline void mapRes_FuncInfo::set_codeset(int index, const std::string& value) {
  codeset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::set_codeset(int index, std::string&& value) {
  codeset_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::set_codeset(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  codeset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::set_codeset(int index, const char* value, size_t size) {
  codeset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kernel.mapRes.FuncInfo.codeSet)
}
inline std::string* mapRes_FuncInfo::_internal_add_codeset() {
  return codeset_.Add();
}
inline void mapRes_FuncInfo::add_codeset(const std::string& value) {
  codeset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::add_codeset(std::string&& value) {
  codeset_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::add_codeset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  codeset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kernel.mapRes.FuncInfo.codeSet)
}
inline void mapRes_FuncInfo::add_codeset(const char* value, size_t size) {
  codeset_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kernel.mapRes.FuncInfo.codeSet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
mapRes_FuncInfo::codeset() const {
  // @@protoc_insertion_point(field_list:kernel.mapRes.FuncInfo.codeSet)
  return codeset_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
mapRes_FuncInfo::mutable_codeset() {
  // @@protoc_insertion_point(field_mutable_list:kernel.mapRes.FuncInfo.codeSet)
  return &codeset_;
}

// map<uint64, .kernel.mapRes.FuncInfo.SASSLineInfo> map_offset_src = 4;
inline int mapRes_FuncInfo::_internal_map_offset_src_size() const {
  return map_offset_src_.size();
}
inline int mapRes_FuncInfo::map_offset_src_size() const {
  return _internal_map_offset_src_size();
}
inline void mapRes_FuncInfo::clear_map_offset_src() {
  map_offset_src_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >&
mapRes_FuncInfo::_internal_map_offset_src() const {
  return map_offset_src_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >&
mapRes_FuncInfo::map_offset_src() const {
  // @@protoc_insertion_point(field_map:kernel.mapRes.FuncInfo.map_offset_src)
  return _internal_map_offset_src();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >*
mapRes_FuncInfo::_internal_mutable_map_offset_src() {
  return map_offset_src_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::kernel::mapRes_FuncInfo_SASSLineInfo >*
mapRes_FuncInfo::mutable_map_offset_src() {
  // @@protoc_insertion_point(field_mutable_map:kernel.mapRes.FuncInfo.map_offset_src)
  return _internal_mutable_map_offset_src();
}

// repeated .kernel.mapRes.FuncInfo.SASSLineInfo SASSLine = 5;
inline int mapRes_FuncInfo::_internal_sassline_size() const {
  return sassline_.size();
}
inline int mapRes_FuncInfo::sassline_size() const {
  return _internal_sassline_size();
}
inline void mapRes_FuncInfo::clear_sassline() {
  sassline_.Clear();
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo* mapRes_FuncInfo::mutable_sassline(int index) {
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FuncInfo.SASSLine)
  return sassline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo_SASSLineInfo >*
mapRes_FuncInfo::mutable_sassline() {
  // @@protoc_insertion_point(field_mutable_list:kernel.mapRes.FuncInfo.SASSLine)
  return &sassline_;
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo& mapRes_FuncInfo::_internal_sassline(int index) const {
  return sassline_.Get(index);
}
inline const ::kernel::mapRes_FuncInfo_SASSLineInfo& mapRes_FuncInfo::sassline(int index) const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.SASSLine)
  return _internal_sassline(index);
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo* mapRes_FuncInfo::_internal_add_sassline() {
  return sassline_.Add();
}
inline ::kernel::mapRes_FuncInfo_SASSLineInfo* mapRes_FuncInfo::add_sassline() {
  ::kernel::mapRes_FuncInfo_SASSLineInfo* _add = _internal_add_sassline();
  // @@protoc_insertion_point(field_add:kernel.mapRes.FuncInfo.SASSLine)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo_SASSLineInfo >&
mapRes_FuncInfo::sassline() const {
  // @@protoc_insertion_point(field_list:kernel.mapRes.FuncInfo.SASSLine)
  return sassline_;
}

// optional uint64 reg_GPR_size = 6;
inline bool mapRes_FuncInfo::_internal_has_reg_gpr_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mapRes_FuncInfo::has_reg_gpr_size() const {
  return _internal_has_reg_gpr_size();
}
inline void mapRes_FuncInfo::clear_reg_gpr_size() {
  reg_gpr_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::_internal_reg_gpr_size() const {
  return reg_gpr_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::reg_gpr_size() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.reg_GPR_size)
  return _internal_reg_gpr_size();
}
inline void mapRes_FuncInfo::_internal_set_reg_gpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  reg_gpr_size_ = value;
}
inline void mapRes_FuncInfo::set_reg_gpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reg_gpr_size(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.reg_GPR_size)
}

// optional uint64 reg_PRED_size = 7;
inline bool mapRes_FuncInfo::_internal_has_reg_pred_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool mapRes_FuncInfo::has_reg_pred_size() const {
  return _internal_has_reg_pred_size();
}
inline void mapRes_FuncInfo::clear_reg_pred_size() {
  reg_pred_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::_internal_reg_pred_size() const {
  return reg_pred_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::reg_pred_size() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.reg_PRED_size)
  return _internal_reg_pred_size();
}
inline void mapRes_FuncInfo::_internal_set_reg_pred_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  reg_pred_size_ = value;
}
inline void mapRes_FuncInfo::set_reg_pred_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reg_pred_size(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.reg_PRED_size)
}

// optional uint64 reg_UGPR_size = 8;
inline bool mapRes_FuncInfo::_internal_has_reg_ugpr_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool mapRes_FuncInfo::has_reg_ugpr_size() const {
  return _internal_has_reg_ugpr_size();
}
inline void mapRes_FuncInfo::clear_reg_ugpr_size() {
  reg_ugpr_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::_internal_reg_ugpr_size() const {
  return reg_ugpr_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::reg_ugpr_size() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.reg_UGPR_size)
  return _internal_reg_ugpr_size();
}
inline void mapRes_FuncInfo::_internal_set_reg_ugpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  reg_ugpr_size_ = value;
}
inline void mapRes_FuncInfo::set_reg_ugpr_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reg_ugpr_size(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.reg_UGPR_size)
}

// optional uint64 reg_UPRED_size = 9;
inline bool mapRes_FuncInfo::_internal_has_reg_upred_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool mapRes_FuncInfo::has_reg_upred_size() const {
  return _internal_has_reg_upred_size();
}
inline void mapRes_FuncInfo::clear_reg_upred_size() {
  reg_upred_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::_internal_reg_upred_size() const {
  return reg_upred_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mapRes_FuncInfo::reg_upred_size() const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FuncInfo.reg_UPRED_size)
  return _internal_reg_upred_size();
}
inline void mapRes_FuncInfo::_internal_set_reg_upred_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  reg_upred_size_ = value;
}
inline void mapRes_FuncInfo::set_reg_upred_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_reg_upred_size(value);
  // @@protoc_insertion_point(field_set:kernel.mapRes.FuncInfo.reg_UPRED_size)
}

// -------------------------------------------------------------------

// mapRes

// map<string, .kernel.mapRes.FuncInfo> testMap = 1;
inline int mapRes::_internal_testmap_size() const {
  return testmap_.size();
}
inline int mapRes::testmap_size() const {
  return _internal_testmap_size();
}
inline void mapRes::clear_testmap() {
  testmap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >&
mapRes::_internal_testmap() const {
  return testmap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >&
mapRes::testmap() const {
  // @@protoc_insertion_point(field_map:kernel.mapRes.testMap)
  return _internal_testmap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >*
mapRes::_internal_mutable_testmap() {
  return testmap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::kernel::mapRes_FuncInfo >*
mapRes::mutable_testmap() {
  // @@protoc_insertion_point(field_mutable_map:kernel.mapRes.testMap)
  return _internal_mutable_testmap();
}

// repeated .kernel.mapRes.FuncInfo FI = 2;
inline int mapRes::_internal_fi_size() const {
  return fi_.size();
}
inline int mapRes::fi_size() const {
  return _internal_fi_size();
}
inline void mapRes::clear_fi() {
  fi_.Clear();
}
inline ::kernel::mapRes_FuncInfo* mapRes::mutable_fi(int index) {
  // @@protoc_insertion_point(field_mutable:kernel.mapRes.FI)
  return fi_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo >*
mapRes::mutable_fi() {
  // @@protoc_insertion_point(field_mutable_list:kernel.mapRes.FI)
  return &fi_;
}
inline const ::kernel::mapRes_FuncInfo& mapRes::_internal_fi(int index) const {
  return fi_.Get(index);
}
inline const ::kernel::mapRes_FuncInfo& mapRes::fi(int index) const {
  // @@protoc_insertion_point(field_get:kernel.mapRes.FI)
  return _internal_fi(index);
}
inline ::kernel::mapRes_FuncInfo* mapRes::_internal_add_fi() {
  return fi_.Add();
}
inline ::kernel::mapRes_FuncInfo* mapRes::add_fi() {
  ::kernel::mapRes_FuncInfo* _add = _internal_add_fi();
  // @@protoc_insertion_point(field_add:kernel.mapRes.FI)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kernel::mapRes_FuncInfo >&
mapRes::fi() const {
  // @@protoc_insertion_point(field_list:kernel.mapRes.FI)
  return fi_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kernel

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mapRes_2eproto
